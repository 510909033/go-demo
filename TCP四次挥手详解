TCP四次挥手详解

TCP四次挥手过程
客户端发起fin位为1的FIN报文，此时客户端进入FIN_WAIT_1状态
服务端接受到FIN 报文后，发送ack应答报文，此时服务端进入close_wait状态
客户端接受到ack应答报文后，进入FIN_WAIT_2状态
服务端处理完数据后，向客户端发送FIN报文，此时服务端进入LAST_ACK状态
客户端接受到FIN报文后，客户端发送应答ack报文，进入TIME_WAIT阶段
服务端接受到ack报文后，断开连接，处于close状态
客户端过一段时间后，也就是2MSL后，进入close状态

主动关闭连接的，才有TIME_WAIT状态

为什么挥手需要四次？
由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。

举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

挥手报文丢失会发生什么？
第一次挥手丢失
当客户端调用close函数后，就会向服务端发送FIN报文，试图与服务端断开联系，此时客户端进入FIN_WAIT_1状态。

如果客户端一直收不到ack应答报文的话，就会触发超时重传机制，最大重传次数由tcp_orphan_retries参数决定。当超过指定次数时，就不再发送报文，直接进入close状态

第二次挥手丢失
当接受到客户端的FIN报文，就会先回应一个ack报文，此时服务端进入close_wait状态。

当ack报文丢失时，ack是不会重传的。服务端的ack报文丢失了，客户端就会触发超时重传，直到收到ack报文或则到达超时重传次数

第三次挥手丢失
当服务端接收到客户端的fin报文时，内核会自动回复ack应答报文，然后处于CLOSE_WAIT状态，他必须等待应用进程调用close函数关闭连接。

调用close函数后，内核就会发出FIN报文，进入LAST_ACK状态，等待客户端返回ack来确认关闭连接。

如果服务端没有收到ack，则会跟客户端重传FIN报文一样

第四次挥手丢失
当客户端接收到服务端发来的FIN报文后，就会回应ack应答报文，进入TIME_WAIT状态。

服务端没有收到ack报文之前，还是处于LAST_ACK状态

如果服务端没有收到ack报文的话，服务端就会重发FIN报文，重发次数仍然由tcp_orphan_retries参数控制

为什么需要TIME_WAIT状态
主要是两方面：

防止错误接收历史报文
保证双方能够正常关闭
防止错误接收历史报文
tcp序列号可能会发生绕回问题，这就意味着无法通过tcp序列号来判断是不是历史报文。(时间戳可以解决是不是历史报文问题，时间戳还可以精确计算RTT)

假设没有TIME_WAIT状态，那么在关闭连接前有个报文被延迟了。关闭后，又重新建立了相同四元组的连接，此时前一个被延迟的数据包到达了(没有到达最大生存时间)，并且正好在接收窗口内，那么服务端就会错误接收，使得数据混乱。


因此有了这个TIME_WAIT字段，可以保证两边的历史数据都被丢弃了，以后的数据包都是新建立连接的。

保证双方能够正常关闭
如果没有TIME_WAIT状态的话，客户端最后一次发送ack应答报文后就进入了close阶段。如果服务端没有收到ack报文的话，就会重传FIN报文，而此时客户端已经close了，就会返回一个RST错误报文。


而有了TIME_WAIT状态的话，客户端并不会着急关闭，而是等待了2MSL再关闭，这样的话就算重传的fin报文也能正确响应，保证了服务端的正确关闭
这里客户端重新接收到了重发的fin报文，time_wait就会重置（也是为了重复报文的消失，不然的话ack报文可能就会到下一次连接中了），相当于可以重传多次fin报文，直到fin报文上限

为什么TIME_WAIT等待时间是2MSL？
MSL是报文的最大生存时间,超过这个时间，报文就将丢弃。
因为tcp是基于ip协议的，ip头中有一个ttl字段，表示ip数据包可以经过的最大路由数。每经过一个节点时，就减一，减为0则丢弃报文。
MSL和TTL的区别：MSL的单位是时间，而TTL的单位则是路由跳数。所以MSL应该大于等于TTL的时间，确保报文已经消亡

TIME_WAIT比较合理的解释是：确保对方能够收到最后一个ack报文，如果服务端没有收到最后的ack报文，就会触发超时重传fin报文，从客户端发送ack报文到接到到服务端重传的fin报文，一去一来，最晚要2msl

为什么不是1MSL？？

因为1MSL可能导致历史数据还没有消亡，导致被后面相同的四元组接收。比如服务端重发的fin报文
客户端发送的ack报文不允许丢失，不然重发的fin报文不能抵达客户端，导致服务端RST关闭
为什么不是4MSL或8MSL

因为如果客户端发送的ack报文丢失，服务端重发的fin报文也丢失了，那么2MSL就不起作用了。那么需要给它设置更长时间？？我们设想在一个丢包率为1%的糟糕网络中，两次连续丢包的概率为万分之一，忽略它显然给解决它更具有实际意义
TIME_WAIT过多有什么危害？
服务端受内存资源占用
当服务端有过多的的TCP连接时，虽然理论上可以建立很多连接，因为一个服务端只监听一个端口，不会导致端口资源受限。但是tcp连接需要占用系统资源，比如cpu资源，文件描述符，线程资源等等
客户端受端口资源的占用
一个tcp占用一个发起连接方的一个本地端口，如果tcp连接过多，则会导致端口资源不足，无法建立新连接
如何优化TIME_WAIT？？
打开net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项
net.ipv4.tcp_tw_reuse之只能用于客户端，当有连接时，客户端会随机找一个time_wait状态超过1s的连接给新连接复用。
net.ipv4.tcp_timestamps开启时间戳，可以保证历史连接不会被下一个相同的四元组接收
net.ipv4.tcp_max_tw_buckets
这个值默认为18000，当系统处于time_wait状态的连接大于这个值时，后面的连接状态就会被重置，不会产生新的time_wait状态
程序中使用 SO_LINGER

当l_onoff为非0，l_linger为0时，调用close关闭连接时就会直接发送RST报文，直接跳过四次挥手阶段
如果服务端要尽量避免TIME_WAIT状态的连接，就尽量不要让服务端来断开连接，承受time_wait状态，而是尽量让我们发布各地的客户端来断开连接

《UNIX网络编程》一书中却说道：TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它。

如果已经建立了连接，但是另一端突然出现故障，会发生什么？？？
TCP有一个保活机制，当一端时间相互直接没有发送数据时，就会触发保活机制。即每隔一段时间都发送一次探测报文给对方，如果几次都不回应的话，就会认为对方已经死亡了，那么就会断开连接。
如果需要使用保活机制，那么需要在soket接口设置so_keepliive才能生效，如果没有设置，则不可以生效
TCP的检测时间有点长，我们可以在应用层实现一个心跳机制。
web服务一般都会提供time_keeplive参数，用来指定http长连接超时时间。
————————————————
版权声明：本文为CSDN博主「small_engineer」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/small_engineer/article/details/124224532